## os

获取home目录

```python
os.environ['HOME']
os.path.expandvars('$HOME')
os.path.expanduser('~')
```

## inspect

1. 对是否是模块、框架、函数进行类型检查

2. 获取源码

3. 获取类或者函数的参数信息

4. 解析堆栈

例如，获取 promotions 模块中的所有类

```python
>>> import inspect
>>> import promotions
>>> 
>>> a = inspect.getmembers(promotions, inspect.isclass)
>>> a
[('Demo', promotions.Demo)]
```

## doctest 模块测试

测试命令：

```shell
python -m doctest <file_path>
```

例如

```python
def factorial(array: int) -> int:
    """ 阶乘
    >>> factorial(1), factorial(2), factorial(3)
    (1, 2, 6)
    """
    result = 1
    for number in range(1, array + 1):
        result *= number
    return result
```

## signal

example:

```python
import signal

def quit_signal_handler(signum,frame):
    pass

signal.signal(signal.SIGINT,quit_signal_handler)        
```

## wsgiref

> 处理单个请求

**方法1**

```python
from wsgiref.simple_server import make_server, demo_app

httpd = make_server('', 8000, demo_app)

sa = httpd.socket.getsockname()
print "Serving HTTP on", sa[0], "port", sa[1], "..."

# serve one request, then exit
httpd.handle_request()
httpd.server_close()
```

运行如上代码， 浏览器访问 http://localhost:8000/xyz?abc,
返回如下内容

```
Hello, /xyz
```

> 并发处理多个http请求

**方法1**

如果有的http请求的处理时间较长，上述方式的httpd服务就会出现阻塞。这种情况就需要httpd能并发处理多个请求。

例如有这样一个http服务：该服务返回‘Hello, word!’, 但是如果请求是‘/sleep’， 则sleep 5秒后才返回结果。如果用**方法****1**，当访问‘http://localhost:8000/sleep’时，同时访问‘http://localhost:8000/’，会出现阻塞。

解决方法时用线程处理http请求。

```python
from wsgiref.simple_server import make_server
import threading

def application(environ, start_response):
  start_response('200 OK', [('Content-Type', 'text/plain')])
  print 'thread %s handing ... : %s' % (os.getpid(), environ['PATH_INFO'])

  if environ['PATH_INFO'] == '/sleep':
    start_time = time.time()
    while (time.time() - start_time) <= 5:
      pass
  return ['Hello, word! \r\n']

def server_forever(thread_num):
   for i in xrange(thread_num):
     t = threading.Thread(target=httpd.serve_forever)
     t.start()

# start 4 threads to run method: serve_forever
server_forever(4)
```

**方法2**

方法1在http服务启动时直接创建4个线程处理http请求，如果希望没有请求时，线程不要创建，请求数量的增加时，再添加处理的线程，

可用如下方法：

```python
from wsgiref.simple_server import make_server
import threading 


def application(*environ*, *start_response*):
  # the same as method1

def server_forever(*max_thread*):
  while True:
      request = httpd.get_request()
      if threading.activeCount() < max_thread:
          t = threading.Thread(targe*=httpd.process_request,
                               args=(request[0], request[1]))
          t.start()

# set max thread num is 4
server_forever(4)
```

## socket

example

```python
import os
import socket
import time

SERVER_ADDRESS = (HOST, PORT) = '', 8888
REQUEST_QUEUE_SIZE = 5

def handle_request(client_connection):
    request = client_connection.recv(1024)
    print(
        'Child PID: {pid}. Parent PID {ppid}'.format(
            pid=os.getpid(),
            ppid=os.getppid(),
        )
    )
    print(request.decode())
    http_response = b"""\
HTTP/1.1 200 OK
Hello, World!
"""
    client_connection.sendall(http_response)
    time.sleep(60)

def serve_forever():
    listen_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    listen_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    listen_socket.bind(SERVER_ADDRESS)
    listen_socket.listen(REQUEST_QUEUE_SIZE)
    print('Serving HTTP on port {port} ...'.format(port=PORT))
    print('Parent PID (PPID): {pid}\n'.format(pid=os.getpid()))
    while True:
        client_connection, client_address = listen_socket.accept()
        pid = os.fork()
        if pid == 0:
            listen_socket.close()
            handle_request(client_connection)
            client_connection.close()
            os._exit(0)

        else:
            client_connection.close()


if __name__ == '__main__':
    serve_forever()
```
