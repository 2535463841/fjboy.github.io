装饰器是可调用的对象，其参数式另一个函数。特性：

1. 能把被装饰的函数其替换成另一个可调用的函数或对象
2. 在加载模块是立即执行

## 1.函数作用域规则

python 不要求声明变量，但是假定在函数中赋值的变量是局部变量。
如果希望函数把变量当作全局变量，需要加 global声明。
示例：

```python
a = 1
def foo():
    """
    >>> foo()
    Traceback (most recent call last):
    ...
    UnboundLocalError: local variable 'a' referenced before assignment
    """
    print(a)
    a = 2
```

## 2.闭包

闭包就是能够读取其他函数内部变量的函数。只有涉及到嵌套函数才会涉及到闭包问题。
闭包会保留定义函数时自由变量（free variable）的绑定，这样调用函数时，虽然定义作用域不起作用，但是仍能使用那些绑定。
示例：

```python
def make_average():
    """
    >>> avg = make_average()
    >>> avg(1)
    1.0
    >>> avg(2)
    1.5
    """
    numbers = []
    def average(new_num):
        numbers.append(new_num)
        return sum(numbers) / len(numbers)
```

**闭包（numbers是自由变量）**

但是，如果将其改造成如下示例，将报错：

```python
def make_average():
    """
    >>> avg = make_average()
    >>> avg(1)
    Traceback (most recent call last):
    ...
    UnboundLocalError: local variable 'total' referenced before assignment
    """
    count = 0
    total = 0

    def average(new_num):
        total += new_num
        count += 1
        return total / count
return average
```

因为，count ，total 是不可变类型。`total += new_num`,相当于 `total = total + new_num`,对total 赋值导致 其变成了局部变量。

## 3.nonlocal

为了解决该问题，python3,引入 关键字 **nonlocal** ，声明变量为自由变量。
示例：

```python
def make_average():
    count = 0
    total = 0              

    def  average(new_num):
        nonlocal total, count
        total += new_num
        count += 1
        return total / count

    return  average  
```

python2可以用可变类型（如dict解决，info= {‘count’:0, 'total': 0}）

## 5.一些有用的装饰器

| 装饰器                      | 说明                                                                        |
|:------------------------ | ------------------------------------------------------------------------- |
| property                 |                                                                           |
| staticmethod             |                                                                           |
| classmethod              |                                                                           |
| functools.wraps          | 将会复制被修饰的方法的相关属性（__name__, __doc__）到新的方法。                                  |
| functools.lru_cache()    | LRU(Least Recently Used)实现备忘功能，它把耗时的函数结果包存起来，避免重复计算。支持参数配置，max_size,typed |
| functools.singledispatch | 单分派泛函数？                                                                   |
