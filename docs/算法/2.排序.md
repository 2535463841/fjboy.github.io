## 冒泡排序

```python
def bubble_sort(array):       
    for i in range(len(array)):         
        for j in range(i, len(array)):
            if array[j] < array[i]:
                tmp = array[i]
                array[i], array[j] = array[j], tmp
        return array  
```

## 选择排序

每一轮只进行一次元素的交换

```python
def select_sort(array):
    for i in range(len(array)):
        min_index = i
        for j in range(i,  len(array)):
            if array[j] <  array[min_index]:
                min_index = j
        array[i], array[min_index] = array[min_index],  array[i]
    return array
```

## 快速排序

快速排序是C.R.A.Hoare于1962年提出的一种划分交换排序。它采用了一种分治的策略，通常称其为分治法(Divide-and-ConquerMethod)。
该方法的基本思想是：

1. 先从数列中取出一个数作为基准数。
2. 分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。
3. 再对左右区间重复第二步，直到各区间只有一个数。 

```python
def quick_sort(array, left, right):
    if left >= right:
        return
    _left = left
    _right = right
    compare = array[left]
    while _left < _right:
        while _left < _right and array[_right] >= compare:
            _right -= 1
        if _left < _right:
            array[_left] = array[_right]
            _left += 1
        while _left < _right and array[_left] < compare:
            _left += 1
        if _left < _right:
            array[_right] = array[_left]
            _right -= 1
    array[_left] = compare
    quick_sort(array, left, _left - 1)
    quick_sort(array, _left + 1, right)
    return _left
```

## 归并排序

归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。
该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

```python
    def merge_sort(array):
    array_temp = array[:]
        def sort(left, right):
        if not left < right:
            return
        middle = int((right + left) / 2)
        sort(left, middle)
        if left != middle:
            sort(middle, right)
        # merge list array[left:right]
        middle = int((right + left) / 2)
        left_array = array_temp[left:middle]
        right_array = array_temp[middle:right]
        index = left
        while left_array and right_array:
            if left_array[0] <= right_array[0]:
                array_temp[index] = left_array.pop(0)
            else:
                array_temp[index] = right_array.pop(0)
            index += 1
        for num in (left_array or right_array):
            array_temp[index] = num
            index += 1
    sort(0, len(array_temp))
        return array_temp
```